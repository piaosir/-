<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>卫星通信链路可视化工具</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: "微软雅黑", Arial, sans-serif;
        }
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        #carrier-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        .slider-container {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 150px;
        }
        input[type="range"] {
            width: 150px;
        }
        .value-display {
            display: inline-block;
            width: 50px;
            text-align: right;
        }
        h3 {
            margin-top: 0;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        #position-indicator {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #satellite-info {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
        }
        .satellite-focused {
            outline: 2px solid yellow;
            outline-offset: 5px;
        }
        #instruction-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 400px;
            z-index: 200;
            text-align: center;
            display: none;
        }
        #instruction-panel button {
            background: #4285f4;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        #legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 2px;
        }
        .mouse-guide {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        .switch-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-left: 10px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info-panel">
            <h3>链路信息</h3>
            <div>上行距离: <span id="uplink-distance">0</span> km</div>
            <div>下行距离: <span id="downlink-distance">0</span> km</div>
            <div>总延迟: <span id="delay">0</span> ms</div>
            <div>上行损耗: <span id="uplink-fsl">0</span> dB</div>
            <div>下行损耗: <span id="downlink-fsl">0</span> dB</div>
        </div>
        
        <div id="carrier-info">
            <h3>载波信息</h3>
            <div>带宽: <span id="bandwidth">36</span> MHz</div>
            <div>频率: <span id="frequencyValue">12</span> GHz</div>
            <div>卫星名称: <span id="satelliteName">自定义卫星</span></div>
            <div class="switch-container">
                <span>显示经纬度网格:</span>
                <label class="switch">
                    <input type="checkbox" id="gridToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <div id="controls">
            <h3>参数控制</h3>
            
            <div class="slider-container">
                <label for="orbitHeight">轨道高度:</label>
                <input type="range" id="orbitHeight" min="1000" max="40000" step="100" value="35786">
                <span class="value-display" id="orbitHeightValue">35786</span> km
            </div>
            
            <div class="slider-container">
                <label for="upLatitude">上行站纬度:</label>
                <input type="range" id="upLatitude" min="-90" max="90" step="0.01" value="39.9">
                <span class="value-display" id="upLatitudeValue">39.9</span>°
            </div>
            
            <div class="slider-container">
                <label for="upLongitude">上行站经度:</label>
                <input type="range" id="upLongitude" min="-180" max="180" step="0.01" value="116.4">
                <span class="value-display" id="upLongitudeValue">116.4</span>°
            </div>
            
            <div class="slider-container">
                <label for="downLatitude">接收站纬度:</label>
                <input type="range" id="downLatitude" min="-90" max="90" step="0.01" value="31.23">
                <span class="value-display" id="downLatitudeValue">31.23</span>°
            </div>
            
            <div class="slider-container">
                <label for="downLongitude">接收站经度:</label>
                <input type="range" id="downLongitude" min="-180" max="180" step="0.01" value="121.47">
                <span class="value-display" id="downLongitudeValue">121.47</span>°
            </div>
            
            <div class="slider-container">
                <label for="frequency">频率:</label>
                <input type="range" id="frequency" min="1" max="40" step="0.1" value="12">
                <span class="value-display" id="frequencyValue">12</span> GHz
            </div>
            
            <div class="slider-container">
                <label for="bandwidth">带宽:</label>
                <input type="range" id="bandwidth" min="1" max="100" step="1" value="36">
                <span class="value-display" id="bandwidthValue">36</span> MHz
            </div>
            
            <div class="slider-container">
                <label for="txPower">发射功率:</label>
                <input type="range" id="txPower" min="0" max="50" step="0.1" value="10">
                <span class="value-display" id="txPowerValue">10</span> W
            </div>
            
            <div class="slider-container">
                <label for="txAntenna">发射天线:</label>
                <input type="range" id="txAntenna" min="0.1" max="10" step="0.1" value="2">
                <span class="value-display" id="txAntennaValue">2</span> m
            </div>
            
            <div class="slider-container">
                <label for="rxAntenna">接收天线:</label>
                <input type="range" id="rxAntenna" min="0.1" max="10" step="0.1" value="3">
                <span class="value-display" id="rxAntennaValue">3</span> m
            </div>
        </div>
        
        <div id="position-indicator">
            轨道位置: <span id="satPositionValue">116.4°E</span>
        </div>
        
        <div id="satellite-info"></div>
        
        <div id="instruction-panel">
            <h3>操作指南</h3>
            <p>点击卫星可以进入移动模式，此时可以：</p>
            <ul style="text-align:left">
                <li>拖动卫星可以改变其轨道位置</li>
                <li>使用鼠标滚轮可以微调卫星位置(每次±0.1°)</li>
                <li>双击卫星可以锁定/解锁当前位置</li>
            </ul>
            <p>点击地球其他位置可退出卫星移动模式</p>
            <button id="closeInstructions">知道了</button>
        </div>
        
        <div id="legend">
            <h4 style="margin-top:0;margin-bottom:5px">图例</h4>
            <div class="legend-item">
                <div class="legend-color" style="background-color:#00ff00"></div>
                <span>上行链路</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color:#ff0000"></div>
                <span>下行链路</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color:#ffff00"></div>
                <span>赤道</span>
            </div>
        </div>
        
        <div class="mouse-guide">
            <div>鼠标操作:</div>
            <div>- 左键点击卫星：选中/取消选中</div>
            <div>- 选中后拖动：移动卫星</div>
            <div>- 选中后滚轮：微调位置(±0.1°)</div>
            <div>- 双击卫星：锁定/解锁位置</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // 初始化场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000033);
        
        // 初始化相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.position.set(0, 20000, 30000);
        
        // 初始化渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // 添加轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // 添加环境光（移除定向光以减少阴影效果）
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        // 地球半径(km)
        const EARTH_RADIUS = 6371;
        
        // 可用卫星名称列表
        const satelliteNames = [
            "CHINASAT 6D (125°E)",
            "CHINASAT 6C (130°E)",
            "CHINASAT 6E (115.5°E)",
            "CHINASAT 9 (92.2°E)",
            "CHINASAT 9B (101.4°E)",
            "CHINASAT 9C (92.2°E)",
            "CHINASAT 10 (110.5°E)",
            "CHINASAT 11 (98°E)",
            "CHINASAT 12 (87.5°E)",
            "CHINASAT 15 (51.5°E)",
            "自定义卫星"
        ];
        
        // 卫星位置数据（经度，东经为正）
        const satellitePositions = {
            "CHINASAT 6D (125°E)": 125,
            "CHINASAT 6C (130°E)": 130,
            "CHINASAT 6E (115.5°E)": 115.5,
            "CHINASAT 9 (92.2°E)": 92.2,
            "CHINASAT 9B (101.4°E)": 101.4,
            "CHINASAT 9C (92.2°E)": 92.2,
            "CHINASAT 10 (110.5°E)": 110.5,
            "CHINASAT 11 (98°E)": 98,
            "CHINASAT 12 (87.5°E)": 87.5,
            "CHINASAT 15 (51.5°E)": 51.5,
            "自定义卫星": 116.4
        };
        
        // 经纬度网格
        let gridHelper = null;
        
        // 创建地球
        function createEarth() {
            const geometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            const texture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                overdraw: 0.5
            });
            const earth = new THREE.Mesh(geometry, material);
            
            // 添加赤道线
            const equatorGeometry = new THREE.TorusGeometry(EARTH_RADIUS * 1.001, 10, 16, 100);
            const equatorMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const equator = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equator.rotation.x = Math.PI / 2;
            earth.add(equator);
            
            scene.add(earth);
            return earth;
        }
        
        // 创建经纬度网格
        function createGrid() {
            // 移除现有网格
            if (gridHelper) {
                scene.remove(gridHelper);
            }
            
            gridHelper = new THREE.Group();
            
            // 经线（子午线）- 每15度一条
            for (let lon = -180; lon < 180; lon += 15) {
                const points = [];
                for (let lat = -90; lat <= 90; lat += 1) {
                    const phi = THREE.MathUtils.degToRad(90 - lat);
                    const theta = THREE.MathUtils.degToRad(lon);
                    
                    points.push(new THREE.Vector3(
                        EARTH_RADIUS * Math.sin(phi) * Math.cos(theta),
                        EARTH_RADIUS * Math.cos(phi),
                        EARTH_RADIUS * Math.sin(phi) * Math.sin(theta)
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x3366ff, 
                    transparent: true,
                    opacity: 0.3
                });
                const meridian = new THREE.Line(geometry, material);
                gridHelper.add(meridian);
            }
            
            // 纬线 - 每15度一条
            for (let lat = -75; lat <= 75; lat += 15) {
                const points = [];
                for (let lon = -180; lon <= 180; lon += 1) {
                    const phi = THREE.MathUtils.degToRad(90 - lat);
                    const theta = THREE.MathUtils.degToRad(lon);
                    
                    points.push(new THREE.Vector3(
                        EARTH_RADIUS * Math.sin(phi) * Math.cos(theta),
                        EARTH_RADIUS * Math.cos(phi),
                        EARTH_RADIUS * Math.sin(phi) * Math.sin(theta)
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x33cc33, 
                    transparent: true,
                    opacity: 0.3
                });
                const parallel = new THREE.Line(geometry, material);
                gridHelper.add(parallel);
            }
            
            scene.add(gridHelper);
            
            return gridHelper;
        }
        
        // 创建小型天线模型
        function createAntenna(color) {
            const group = new THREE.Group();
            
            // 底座
            const baseGeometry = new THREE.CylinderGeometry(50, 80, 40, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            group.add(base);
            
            // 天线
            const geometry = new THREE.ConeGeometry(100, 300, 16);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const antenna = new THREE.Mesh(geometry, material);
            antenna.position.y = 150;
            antenna.rotation.x = Math.PI;
            group.add(antenna);
            
            return group;
        }
        
        // 创建更真实的卫星模型
        function createSatellite() {
            const group = new THREE.Group();
            group.name = "satellite";
            
            // 卫星主体 - 长方体
            const bodyGeometry = new THREE.BoxGeometry(300, 200, 400);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xaaaaaa,
                emissive: 0x333333,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            
            // 太阳能板
            const solarPanelGeometry = new THREE.BoxGeometry(800, 10, 400);
            const solarPanelMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2255aa,
                emissive: 0x111111,
                emissiveIntensity: 0.2
            });
            const solarPanel1 = new THREE.Mesh(solarPanelGeometry, solarPanelMaterial);
            solarPanel1.position.x = 550;
            group.add(solarPanel1);
            
            const solarPanel2 = new THREE.Mesh(solarPanelGeometry, solarPanelMaterial);
            solarPanel2.position.x = -550;
            group.add(solarPanel2);
            
            // 通信天线
            const antennaGeometry = new THREE.CylinderGeometry(30, 100, 200, 32);
            const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
            const antenna1 = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna1.position.z = 250;
            antenna1.rotation.x = Math.PI / 2;
            group.add(antenna1);
            
            // 卫星名称标签
            const textSprite = makeTextSprite("自定义卫星", { fontsize: 80 });
            textSprite.position.set(0, 300, 0);
            group.add(textSprite);
            
            return group;
        }
        
        // 创建文本精灵
        function makeTextSprite(message, parameters) {
            if (parameters === undefined) parameters = {};
            
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 70;
            const borderThickness = parameters.borderThickness || 4;
            const borderColor = parameters.borderColor || { r:0, g:0, b:0, a:1.0 };
            const backgroundColor = parameters.backgroundColor || { r:0, g:0, b:0, a:0.8 };
            const textColor = parameters.textColor || { r:255, g:255, b:255, a:1.0 };
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = "Bold " + fontsize + "px " + fontface;
            
            // 计算文本宽度
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            
            // 设置画布尺寸
            canvas.width = textWidth + borderThickness * 2;
            canvas.height = fontsize * 1.4 + borderThickness * 2;
            context.font = "Bold " + fontsize + "px " + fontface;
            
            // 文本背景
            context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
                              + backgroundColor.b + "," + backgroundColor.a + ")";
            context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
                              + borderColor.b + "," + borderColor.a + ")";
            context.lineWidth = borderThickness;
            roundRect(context, borderThickness/2, borderThickness/2, 
                     textWidth + borderThickness, fontsize * 1.4 + borderThickness, 8);
            
            // 文本
            context.fillStyle = "rgba(" + textColor.r + "," + textColor.g + ","
                              + textColor.b + "," + textColor.a + ")";
            context.fillText(message, borderThickness, fontsize + borderThickness);
            
            // 创建纹理
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 5, 1.0);
            
            return sprite;
        }
        
        // 绘制圆角矩形
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x+r, y);
            ctx.lineTo(x+w-r, y);
            ctx.quadraticCurveTo(x+w, y, x+w, y+r);
            ctx.lineTo(x+w, y+h-r);
            ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
            ctx.lineTo(x+r, y+h);
            ctx.quadraticCurveTo(x, y+h, x, y+h-r);
            ctx.lineTo(x, y+r);
            ctx.quadraticCurveTo(x, y, x+r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();   
        }
        
        // 创建带刻度的轨道位置轴
        function createOrbitAxis(radius) {
            const group = new THREE.Group();
            
            // 白色轨道轴
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.LineBasicMaterial({ color: 0xffffff });
            
            const points = [];
            const segments = 360;
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    radius * Math.cos(theta),
                    0,
                    radius * Math.sin(theta)
                ));
            }
            
            geometry.setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            group.add(line);
            
            // 添加刻度标记
            for (let i = 0; i < 360; i += 10) {
                const theta = THREE.MathUtils.degToRad(i);
                const start = new THREE.Vector3(
                    radius * Math.cos(theta),
                    0,
                    radius * Math.sin(theta)
                );
                const end = new THREE.Vector3(
                    (radius + 300) * Math.cos(theta),
                    0,
                    (radius + 300) * Math.sin(theta)
                );
                
                const markGeometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                const mark = new THREE.Line(markGeometry, material);
                group.add(mark);
                
                // 添加度数标签 (每30度)
                if (i % 30 === 0) {
                    // 创建文本精灵而不是TextGeometry
                    const label = makeTextSprite(formatLongitude(i), { fontsize: 50 });
                    label.position.set(
                        (radius + 800) * Math.cos(theta),
                        0,
                        (radius + 800) * Math.sin(theta)
                    );
                    group.add(label);
                }
            }
            
            return group;
        }
        
        // 格式化经度显示
        function formatLongitude(degrees) {
            // 调整为0-360范围，然后转换为-180到180
            degrees = (degrees) % 360;
            if (degrees > 180) degrees -= 360;
            
            return degrees >= 0 ? `${degrees}°E` : `${-degrees}°W`;
        }
        
        // 创建通信链路
        function createLinkLine(color) {
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8 
            });
            const geometry = new THREE.BufferGeometry();
            const line = new THREE.Line(geometry, material);
            return line;
        }
        
        // 计算链路参数
        function calculateLinkParameters(groundPos, satPos, frequency, txPower, txAntennaDiam, rxAntennaDiam) {
            // 计算距离(km)
            const distance = groundPos.distanceTo(satPos);
            
            // 计算传播延迟(ms)
            const delay = (distance / 300000) * 1000; // 光速约300,000 km/s
            
            // 计算自由空间损耗(dB)
            const wavelength = 300 / frequency; // 波长(mm)
            const fsl = 20 * Math.log10(distance) + 20 * Math.log10(frequency) + 92.45;
            
            // 计算天线增益(dBi)
            const txGain = 20 * Math.log10(txAntennaDiam) + 20 * Math.log10(frequency) + 17.8;
            const rxGain = 20 * Math.log10(rxAntennaDiam) + 20 * Math.log10(frequency) + 17.8;
            
            // 计算SFDref (假设值)
            const sfdRef = (-90 + (frequency / 12) * 5).toFixed(1);
            
            return {
                distance: distance.toFixed(2),
                delay: delay.toFixed(2),
                fsl: fsl.toFixed(2),
                sfdRef: sfdRef
            };
        }
        
        // 创建场景对象
        const earth = createEarth();
        const upStation = createAntenna(0x00ff00); // 绿色上行站
        const downStation = createAntenna(0xff0000); // 红色接收站
        const satellite = createSatellite();
        let orbitAxis = createOrbitAxis(EARTH_RADIUS + 35786);
        const uplinkLine = createLinkLine(0x00ff00); // 绿色上行链路
        const downlinkLine = createLinkLine(0xff0000); // 红色下行链路
        
        scene.add(upStation);
        scene.add(downStation);
        scene.add(satellite);
        scene.add(orbitAxis);
        scene.add(uplinkLine);
        scene.add(downlinkLine);
        
        // 卫星信息显示元素
        const satelliteInfo = document.getElementById('satellite-info');
        
        // 卫星交互状态
        let isDragging = false;
        let isSatelliteFocused = false;
        let isPositionLocked = false;
        let currentAngle = THREE.MathUtils.degToRad(-116.4); // 初始位置对应北京经度
        let initialShowInstructions = true;
        let currentSatelliteName = "自定义卫星";
        
        // 更新卫星标签文本
        function updateSatelliteLabel(name) {
            // 移除现有标签
            satellite.children.forEach(child => {
                if (child instanceof THREE.Sprite) {
                    satellite.remove(child);
                }
            });
            
            // 添加新标签
            const textSprite = makeTextSprite(name, { fontsize: 80 });
            textSprite.position.set(0, 300, 0);
            satellite.add(textSprite);
            
            // 更新载波信息面板
            document.getElementById('satelliteName').textContent = name;
        }
        
        // 显示操作指南
        function showInstructions() {
            document.getElementById('instruction-panel').style.display = 'block';
        }
        
        // 关闭操作指南
        document.getElementById('closeInstructions').addEventListener('click', function() {
            document.getElementById('instruction-panel').style.display = 'none';
            initialShowInstructions = false;
        });
        
        // 鼠标事件处理
        function onMouseDown(event) {
            // 检查是否点击了卫星
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObject(satellite, true);
            
            if (intersects.length > 0) {
                if (isPositionLocked) {
                    // 如果位置已锁定，显示提示信息
                    satelliteInfo.textContent = "位置已锁定，双击解锁";
                    satelliteInfo.style.backgroundColor = "rgba(255,0,0,0.7)";
                    setTimeout(() => {
                        satelliteInfo.style.backgroundColor = "rgba(0,0,0,0.7)";
                    }, 1000);
                    return;
                }
                
                isDragging = true;
                isSatelliteFocused = true;
                satellite.children.forEach(child => {
                    if (child instanceof THREE.Mesh) {
                        child.material.emissive.setHex(0xffff00);
                        child.material.emissiveIntensity = 0.5;
                    }
                });
                
                // 首次选中卫星时显示操作指南
                if (initialShowInstructions) {
                    showInstructions();
                }
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                
                // 禁用相机轨道控制
                controls.enabled = false;
            } else {
                // 点击其他地方取消聚焦
                if (isSatelliteFocused) {
                    satellite.children.forEach(child => {
                        if (child instanceof THREE.Mesh) {
                            child.material.emissive.setHex(0x333333);
                            child.material.emissiveIntensity = 0.3;
                        }
                    });
                    isSatelliteFocused = false;
                }
                
                // 启用相机轨道控制
                controls.enabled = true;
            }
        }
        
        function onMouseMove(event) {
            if (isDragging && !isPositionLocked) {
                const mouse = new THREE.Vector2(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1
                );
                
                // 将相机空间中的射线转换到全局空间
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // 创建平面以提供更精确的移动
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const point = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, point);
                
                // 计算与原点的角度
                const angle = Math.atan2(point.z, point.x);
                currentAngle = angle;
                
                // 更新卫星位置
                updateSatellitePosition();
                
                // 更新链路
                updateLinkLines();
                
                // 计算并显示链路参数
                updateLinkParameters();
                
                // 更新卫星信息
                const degrees = THREE.MathUtils.radToDeg(-currentAngle);
                const formattedDegrees = formatLongitude(degrees);
                satelliteInfo.textContent = `轨道位置: ${formattedDegrees}`;
            }
            
            // 更新卫星信息显示位置
            updateSatelliteInfoPosition();
        }
        
        function onMouseUp() {
            isDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            
            // 启用相机轨道控制
            controls.enabled = true;
            
            // 更新载波信息面板中的显示
            if (currentSatelliteName === "自定义卫星") {
                // 如果是自定义卫星，检查当前位置是否与已知卫星接近
                const degrees = THREE.MathUtils.radToDeg(-currentAngle) % 360;
                const longitude = degrees > 180 ? degrees - 360 : degrees;
                
                let matchFound = false;
                for (const [name, pos] of Object.entries(satellitePositions)) {
                    if (name !== "自定义卫星" && Math.abs(longitude - pos) < 1) {
                        currentSatelliteName = name;
                        updateSatelliteLabel(name);
                        matchFound = true;
                        break;
                    }
                }
                
                if (!matchFound) {
                    updateSatelliteLabel("自定义卫星");
                }
            }
        }
        
        // 滚轮事件处理 - 微调卫星位置
        function onMouseWheel(event) {
            if (isSatelliteFocused && !isPositionLocked) {
                // 聚焦卫星时，滚轮调整卫星位置
                event.preventDefault();
                
                // 微调角度 (±0.1度)
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                currentAngle += THREE.MathUtils.degToRad(delta);
                
                // 更新卫星位置
                updateSatellitePosition();
                
                // 更新链路
                updateLinkLines();
                
                // 计算并显示链路参数
                updateLinkParameters();
                
                // 更新卫星信息
                const degrees = THREE.MathUtils.radToDeg(-currentAngle);
                const formattedDegrees = formatLongitude(degrees);
                satelliteInfo.textContent = `轨道位置: ${formattedDegrees}（滚轮微调中）`;
            } else {
                // 未聚焦卫星时，正常缩放
                controls.handleMouseWheel(event);
            }
        }
        
        // 双击事件 - 锁定/解锁卫星位置
        function onDoubleClick(event) {
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObject(satellite, true);
            
            if (intersects.length > 0) {
                isPositionLocked = !isPositionLocked;
                
                if (isPositionLocked) {
                    // 锁定位置 - 修改卫星外观
                    satellite.children.forEach(child => {
                        if (child instanceof THREE.Mesh) {
                            child.material.emissive.setHex(0xff0000);
                            child.material.emissiveIntensity = 0.3;
                        }
                    });
                    satelliteInfo.textContent = "位置已锁定";
                } else {
                    // 解锁位置
                    satellite.children.forEach(child => {
                        if (child instanceof THREE.Mesh) {
                            child.material.emissive.setHex(0xffff00);
                            child.material.emissiveIntensity = 0.5;
                        }
                    });
                    satelliteInfo.textContent = "位置已解锁";
                }
                
                setTimeout(() => {
                    const degrees = THREE.MathUtils.radToDeg(-currentAngle);
                    const formattedDegrees = formatLongitude(degrees);
                    satelliteInfo.textContent = `轨道位置: ${formattedDegrees}`;
                }, 1000);
            }
        }
        
        // 网格开关事件处理
        document.getElementById('gridToggle').addEventListener('change', function(event) {
            if (event.target.checked) {
                createGrid();
            } else if (gridHelper) {
                scene.remove(gridHelper);
                gridHelper = null;
            }
        });
        
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('wheel', onMouseWheel, { passive: false });
        document.addEventListener('dblclick', onDoubleClick);
        
        // 更新卫星位置
        function updateSatellitePosition() {
            const radius = EARTH_RADIUS + parseFloat(document.getElementById('orbitHeight').value);
            satellite.position.x = radius * Math.cos(currentAngle);
            satellite.position.z = radius * Math.sin(currentAngle);
            
            // 卫星始终面向地球
            satellite.lookAt(0, 0, 0);
            
            // 更新位置指示器
            const degrees = THREE.MathUtils.radToDeg(-currentAngle);
            const formattedDegrees = formatLongitude(degrees);
            document.getElementById('satPositionValue').textContent = formattedDegrees;
        }
        
        // 更新卫星信息显示位置
        function updateSatelliteInfoPosition() {
            const vector = new THREE.Vector3();
            vector.setFromMatrixPosition(satellite.matrixWorld);
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
            
            satelliteInfo.style.left = `${x + 10}px`;
            satelliteInfo.style.top = `${y}px`;
        }
        
        // 更新地面站位置
        function updateStationPositions() {
            const upLat = parseFloat(document.getElementById('upLatitude').value);
            const upLon = parseFloat(document.getElementById('upLongitude').value);
            const downLat = parseFloat(document.getElementById('downLatitude').value);
            const downLon = parseFloat(document.getElementById('downLongitude').value);
            
            // 将角度转换为弧度
            const upLatRad = THREE.MathUtils.degToRad(upLat);
            const upLonRad = THREE.MathUtils.degToRad(-upLon); // 注意这里需要取反来符合坐标系
            const downLatRad = THREE.MathUtils.degToRad(downLat);
            const downLonRad = THREE.MathUtils.degToRad(-downLon); // 注意这里需要取反来符合坐标系
            
            // 上行站位置
            upStation.position.x = EARTH_RADIUS * Math.cos(upLatRad) * Math.cos(upLonRad);
            upStation.position.y = EARTH_RADIUS * Math.sin(upLatRad);
            upStation.position.z = EARTH_RADIUS * Math.cos(upLatRad) * Math.sin(upLonRad);
            
            // 上行站朝向天顶
            upStation.lookAt(0, 0, 0);
            upStation.position.normalize().multiplyScalar(EARTH_RADIUS);
            const zenithDirection = upStation.position.clone().normalize();
            const lookPoint = upStation.position.clone().add(zenithDirection.multiplyScalar(-1000));
            upStation.lookAt(lookPoint);
            
            // 接收站位置
            downStation.position.x = EARTH_RADIUS * Math.cos(downLatRad) * Math.cos(downLonRad);
            downStation.position.y = EARTH_RADIUS * Math.sin(downLatRad);
            downStation.position.z = EARTH_RADIUS * Math.cos(downLatRad) * Math.sin(downLonRad);
            
            // 接收站朝向天顶
            downStation.lookAt(0, 0, 0);
            downStation.position.normalize().multiplyScalar(EARTH_RADIUS);
            const zenithDirection2 = downStation.position.clone().normalize();
            const lookPoint2 = downStation.position.clone().add(zenithDirection2.multiplyScalar(-1000));
            downStation.lookAt(lookPoint2);
        }
        
        // 更新链路线条
        function updateLinkLines() {
            // 上行链路
            const upPositions = [
                upStation.position.x,
                upStation.position.y,
                upStation.position.z,
                satellite.position.x,
                satellite.position.y,
                satellite.position.z
            ];
            uplinkLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(upPositions, 3));
            
            // 下行链路
            const downPositions = [
                satellite.position.x,
                satellite.position.y,
                satellite.position.z,
                downStation.position.x,
                downStation.position.y,
                downStation.position.z
            ];
            downlinkLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(downPositions, 3));
        }
        
        // 更新链路参数
        function updateLinkParameters() {
            const frequency = parseFloat(document.getElementById('frequency').value);
            const txPower = parseFloat(document.getElementById('txPower').value);
            const txAntenna = parseFloat(document.getElementById('txAntenna').value);
            const rxAntenna = parseFloat(document.getElementById('rxAntenna').value);
            const bandwidth = parseFloat(document.getElementById('bandwidth').value);
            
            const uplinkParams = calculateLinkParameters(
                upStation.position,
                satellite.position,
                frequency,
                txPower,
                txAntenna,
                0.5 // 假设卫星接收天线直径0.5m
            );
            
            const downlinkParams = calculateLinkParameters(
                satellite.position,
                downStation.position,
                frequency,
                1, // 假设卫星转发功率1W
                0.5, // 假设卫星发射天线直径0.5m
                rxAntenna
            );
            
            document.getElementById('uplink-distance').textContent = uplinkParams.distance;
            document.getElementById('downlink-distance').textContent = downlinkParams.distance;
            document.getElementById('delay').textContent = (parseFloat(uplinkParams.delay) + parseFloat(downlinkParams.delay)).toFixed(2);
            document.getElementById('uplink-fsl').textContent = uplinkParams.fsl;
            document.getElementById('downlink-fsl').textContent = downlinkParams.fsl;
            
            // 更新卫星信息
            if (!isDragging && !isPositionLocked) {
                const degrees = THREE.MathUtils.radToDeg(-currentAngle);
                const formattedDegrees = formatLongitude(degrees);
                satelliteInfo.textContent = `SFDref: ${uplinkParams.sfdRef} dBW/m² | 位置: ${formattedDegrees}`;
            }
            
            // 更新载波信息
            document.getElementById('bandwidth').textContent = bandwidth;
            document.getElementById('frequencyValue').textContent = frequency;
        }
        
        // 初始位置
        function updatePositions(orbitHeight, upLatitude, upLongitude, downLatitude, downLongitude) {
            // 更新轨道轴
            scene.remove(orbitAxis);
            orbitAxis = createOrbitAxis(EARTH_RADIUS + orbitHeight);
            scene.add(orbitAxis);
            
            // 更新卫星位置 - 正确处理经度转换为角度
            if (currentSatelliteName !== "自定义卫星") {
                // 使用预设卫星位置
                const position = satellitePositions[currentSatelliteName];
                currentAngle = THREE.MathUtils.degToRad(-position);
            }
            updateSatellitePosition();
            
            // 更新地面站位置
            updateStationPositions();
            
            // 更新链路
            updateLinkLines();
            
            // 计算并显示链路参数
            updateLinkParameters();
        }
        
        // 更新UI显示
        function updateUI() {
            const orbitHeight = parseFloat(document.getElementById('orbitHeight').value);
            const upLatitude = parseFloat(document.getElementById('upLatitude').value);
            const upLongitude = parseFloat(document.getElementById('upLongitude').value);
            const downLatitude = parseFloat(document.getElementById('downLatitude').value);
            const downLongitude = parseFloat(document.getElementById('downLongitude').value);
            const frequency = parseFloat(document.getElementById('frequency').value);
            const bandwidth = parseFloat(document.getElementById('bandwidth').value);
            const txPower = parseFloat(document.getElementById('txPower').value);
            const txAntenna = parseFloat(document.getElementById('txAntenna').value);
            const rxAntenna = parseFloat(document.getElementById('rxAntenna').value);
            
            // 更新参数显示
            document.getElementById('orbitHeightValue').textContent = orbitHeight;
            document.getElementById('upLatitudeValue').textContent = upLatitude;
            document.getElementById('upLongitudeValue').textContent = upLongitude;
            document.getElementById('downLatitudeValue').textContent = downLatitude;
            document.getElementById('downLongitudeValue').textContent = downLongitude;
            document.getElementById('frequencyValue').textContent = frequency;
            document.getElementById('bandwidthValue').textContent = bandwidth;
            document.getElementById('txPowerValue').textContent = txPower;
            document.getElementById('txAntennaValue').textContent = txAntenna;
            document.getElementById('rxAntennaValue').textContent = rxAntenna;
            
            // 更新位置
            updatePositions(orbitHeight, upLatitude, upLongitude, downLatitude, downLongitude);
        }
        
        // 窗口大小调整
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 初始更新
        updateUI();
        
        // 添加事件监听器
        document.getElementById('orbitHeight').addEventListener('input', updateUI);
        document.getElementById('upLatitude').addEventListener('input', updateUI);
        document.getElementById('upLongitude').addEventListener('input', updateUI);
        document.getElementById('downLatitude').addEventListener('input', updateUI);
        document.getElementById('downLongitude').addEventListener('input', updateUI);
        document.getElementById('frequency').addEventListener('input', updateUI);
        document.getElementById('bandwidth').addEventListener('input', updateUI);
        document.getElementById('txPower').addEventListener('input', updateUI);
        document.getElementById('txAntenna').addEventListener('input', updateUI);
        document.getElementById('rxAntenna').addEventListener('input', updateUI);
        
        // 键盘事件处理 - 微调卫星位置
        document.addEventListener('keydown', function(event) {
            if (isSatelliteFocused && !isPositionLocked) {
                let delta = 0;
                
                // 左右箭头键微调卫星位置
                if (event.key === 'ArrowLeft') {
                    delta = 0.1;
                } else if (event.key === 'ArrowRight') {
                    delta = -0.1;
                }
                
                if (delta !== 0) {
                    event.preventDefault();
                    currentAngle += THREE.MathUtils.degToRad(delta);
                    
                    // 更新卫星位置
                    updateSatellitePosition();
                    
                    // 更新链路
                    updateLinkLines();
                    
                    // 计算并显示链路参数
                    updateLinkParameters();
                }
            }
        });
        
        // 双击卫星事件处理
        // 已包含在 onDoubleClick 函数中
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            
            // 更新卫星信息位置
            updateSatelliteInfoPosition();
        }
        
        animate();
    </script>
</body>
</html>